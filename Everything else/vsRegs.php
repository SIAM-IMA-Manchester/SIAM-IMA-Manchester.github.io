<?php


/********
  TO DO:
  - Forgot password/code

/**************************************************************
 *                                                            *
 *  vsRegs -- a class to handle simple registrations      *
 *                                                            *
 *  Created 2013. by Vedran Sego <vsego@vsego.org>            *
 *                                                            *
 **************************************************************/

/*******************
 *** Basic class ***
 *******************/

abstract class vsRegsBasic {

  public $catchPDOException = true;
  public $breakOnBindErrors = false;
  public $lastPDOerrorInfo = array('00000', 0, "");
  public $dbh = null;

  // Check that a PDO error has the exact given code and subcode
  protected function checkErrorInfo($code, $subcode = null, $info = null) {
    if (!isset($info))
      $info = $this->lastPDOerrorInfo;
    elseif (gettype($info) === "object")
      $info = $info->errorInfo();
    return ($info[0] === $code && (!isset($subcode) || $info[1] === (int)$subcode));
  }

  // Execute an SQL query
  // Return PDOStatement object (or false if unsuccessfull)
  protected function query($query, $values = null) {
    if ($this->catchPDOException)
      try {
        //foreach (debug_backtrace() as $trace)
        //  echo "$trace[function] (line $trace[line] in $trace[file])<br>";
        $sth = $this->dbh->prepare($query);
      } catch (PDOException $e) {
        $this->lastPDOerrorInfo = $sth->errorInfo();
        $sth = false;
      }
    else
      $sth = $this->dbh->prepare($query);
    if (!$sth) return false;
    if (is_array($values))
      foreach ($values as $key => &$val)
        if (!$sth->bindParam(':'.$key, $val) && $this->breakOnBindErrors) {
          $this->lastPDOerrorInfo = $sth->errorInfo();
          return false;
        }
    $sth->execute();
    $this->lastPDOerrorInfo = $sth->errorInfo();
    return $sth;
  }

  // Create required tables; return true if successful
  public function createTables() {
    return true;
  }

  // Execute an SQL query
  // If it fails because the table doesn't exist, attempt to execute $createTables()
  // Return PDOStatement object (or false if unsuccessfull)
  protected function queryAndCreate($query, $values = null) {
    $first = true;
    while (1) {
      $sth = $this->query($query, $values);
      if (!$sth) return false;
      $this->lastPDOerrorInfo = $sth->errorInfo();
      if ($this->lastPDOerrorInfo[0] == '00000') return $sth;
      if ($first && $this->checkErrorInfo('42S02', '1146')) {
        $first = false;
        if (!$this->createTables()) return false;
        continue;
      }
      return false;
    }
  }

  // Used for translations
  // Fields and plugins will just call their parent's function.
  abstract public function addText($code, $text);
  abstract public function addTexts($texts); // array("code" => "text",...)
  abstract public function text($text, $params = null);

  // When making a translation, it is best to override this method,
  // WITHOUT calling this one from the parent class, to save on redundancy
  public function setDefaultTexts() {}

}

/*************************
 *** Basic field class ***
 *************************/

abstract class vsRegsField extends vsRegsBasic {

  protected $name = null;
  public $deadlineDesc = null; // i.e., "Abstract submission" for the abstract files
  protected $htmlParams = array();
  protected $value = null;
  protected $parent = null;
  public $idx = -1; // Handled by the vsRegs main class to allow the field to know its position
  public $editable = true; // If false, htmlOutput() will be used instead of htmlInput() and htmlEdit()
  public $mandatory = false; // Is this field mandatory
  public $title = ""; // Title in the registration/editing/info box
  public $subtitle = ""; // If not empty, this gets added to the $title in the default getTitle() method
  public $subtitleCss = "hint"; // CSS of the span element in which $subtitle gets wrapped
  public $visibleInRegisterBox = true; // Should this field be visible in registration box generated by the parent object
    // If true, the code is generated as usual, but before table and without tr, th and td elements
    // Usefull for hidden fields or large fields (title can be added via plugin system, through beforeRegisterBoxFieldData()
    // This option affects only HTML output, not the data retrieval
  public $visibleInMembersTable = true; // Should this field be visible in tables generated by the parent object
                                        // This option affects only HTML output, not the data retrieval
  public $maxCellLength = null;

  public function __construct($name, $title = "", $mandatory = false, $htmlParams = null) {
    $this->name = $name;
    $this->title = $title;
    $this->mandatory = $mandatory;
    if (is_array($htmlParams)) $this->setHtmlParams($htmlParams);
  }

  // Set parent (vsRegs object)
  public function setParent($parent) {
    $this->parent = $parent;
    $this->catchPDOException =& $this->parent->catchPDOException;
    $this->breakOnBindErrors =& $this->parent->breakOnBindErrors;
    $this->lastPDOerrorInfo =& $this->parent->lastPDOerrorInfo;
    $this->dbh =& $this->parent->dbh;
    $this->addText('mandatoryField', 'Field "{title}" is mandatory.');
    $this->setDefaultTexts();
  }

  public function addText($code, $text) {
    $this->parent->addText($code, $text);
  }

  public function addTexts($texts) {
    $this->parent->addTexts($texts);
  }

  public function text($text, $params = null) {
    return $this->parent->text($text, $params);
  }

  public function htmlParams2str($params, $prefix = " ") {
    return $this->parent->htmlParams2str($params, $prefix);
  }

  public function isVisible($scope = vsRegs::SCOPE_INPUT) {
    return true;
  }

  // Return the array of the tables (null or empty array for nothing)
  // Delete usually doesn't need any data (apart from the currentId),
  // so this is used to provide the facilities to get data, while keeping
  // it optimized (i.e., not reading if it's not needed) at the same time.
  public function dataRequiredForDelete() {
    return null;
  }

  // Handle here anything that is not part of the data tables
  // $id == null -- delete all data
  // $data contains raw data (or an empty array if no data was loaded)
  // Returns true on success, false otherwise
  public function deleteData($id = null, $data = null) {
    return true;
  }

  public function getTitle() {
    return $this->title;
  }

  public function getSubtitle() {
    if (empty($this->subtitle)) return "";
    if (empty($this->subtitleCSS) && empty($this->parent->params["subtitleCSS"])) return $this->subtitle;
    $subtitleCSS = (empty($this->subtitleCSS) ? $this->parent->params["subtitleCSS"] : $this->subtitleCSS);
    return "<span class=\"$subtitleCSS\">".$this->subtitle."</span>";
  }

  public function getColumnTitle() {
    return $this->title;
  }

  public function getInfoboxTitleParams($scope = vsRegs::SCOPE_INPUT) {
    return null;
  }

  public function getInfoboxInputParams($scope = vsRegs::SCOPE_INPUT) {
    return null;
  }

  public function getColumnTitleParams() {
    return null;
  }

  public function getRowParams() {
    return null;
  }

  public function getCellParams() {
    $text = $this->htmlOutput(array());
    if (isset($this->maxCellLength) && strlen($text) > $this->maxCellLength)
      return array("title" => htmlspecialchars($text));
    return null;
  }

  // The following two functions are used to optimize performance
  // Parent vsReg object will simply read the data from all the tables at once
  // and put them in the array, for easy access by its vsRegsField objects

  // All the tables from which the data is to be read
  // Should return a string or an array of strings (or null if no extra tables are used)
  public function tablesToRead() {
    return null;
  }
  // Return the list of extra tables needed for this field (null or empty array if none)
  public function requiredTables() {
    return null;
  }

  public function tableName($name) {
    if (isset($this->parent) && $this->parent instanceof vsRegs)
      return $this->parent->tableName($name);
    return false;
  }

  // Get variable htmlParams
  public function getHtmlParams() {
    return $this->htmlParams;
  }

  // Set variable htmlParams
  public function setHtmlParams($htmlParams) {
    $hp = array();
    foreach ($htmlParams as $key => $val)
      if (gettype($key) === "string") {
        $key = strtolower($key);
        if ($key != "name") $hp[$key] = $val;
      }
    $this->htmlParams = $hp;
  }

  // Get variable name
  public function getName() {
    return $this->name;
  }

  // Get variable value
  public function getValue() {
    return $this->value;
  }

  // Set variable value
  public function setValue($value) {
    if (empty($value) && $this->mandatory)
      return $this->parent->addError('mandatoryField', array('title' => $this->getTitle()));
    $this->value = $value;
    return true;
  }

  // Get value from an associative field obtained by PDOStatement::fetch()
  // Data gets saved in internal variables, probably $value and returned as a result
  public function importValueFromDBrow($row) {
    if (isset($row[$this->name])) return $this->setValue($row[$this->name]);
    return true;
  }

  // Export the associative array of values to be saved to the database
  // Format: array("table1" => array("key1" => "value1",...), "table2" => ...)
  // To save to the main table, use "attend" as a tablename
  // This has to be consistent with the columns and extra tables defined by this class
  public function exportValueToDBrow() {
    $value = $this->getValue();
    if (isset($value)) return array("attend" => array($this->getName() => $value)); else return null;
  }

  // Get variable value from $_POST
  // Return true for success
  // Data gets saved in internal variables, probably $value
  public function readValueFromPost($scope = vsRegs::SCOPE_INPUT) {
    if ($this->parent->deadlinePassed($this->deadlineDesc)) return true;
    $name = $this->getName();
    if (isset($_POST[$name])) return $this->setValue($_POST[$name]);
    return true;
  }

  // Clear variable value
  public function clearValue() {
    $this->value = null;
  }

  // Six methods, in case additional storage or some action is needed (i.e., saving data in extra tables)
  // Return true on success, false otherwise
  // Note: $this->parent->getCurrentId() returns the id of the current field in the main table

  // These can do some preparation; no ID or anything is available in case of an insert (only ID is available in case of an edit)
  public function beforeInsert() {
    return true;
  }
  public function beforeEdit() {
    return true;
  }
  // Actual saving can be done here; ID is always available, but currentData() should not be invoked
  public function insertData() {
    return true;
  }
  public function editData() {
    return true;
  }
  // For post-saving activities; both getCurrentId() and currentData() are available
  public function afterInsert() {
    return true;
  }
  public function afterEdit() {
    return true;
  }

  // Recommended to put at the end of return values of sqlDefinition()
  protected function sqlDefinitionNull() {
    return ($this->mandatory ? "not" : "default")." null";
  }

  // These functions do the actual code generation

  // Generate code for the HTML input field
  abstract protected function htmlInput($params);
  // Generate code for the HTML edit field (usually similar to input, with the value added)
  abstract protected function htmlEdit($params);
  // Return string to be outputed in HTML page
  abstract protected function htmlOutput($params);
  // Return string to be outputed in the table of users
  protected function htmlCell($params) {
    $text = $this->htmlOutput($params);
    if (isset($this->maxCellLength) && strlen($text) > $this->maxCellLength)
      return ($this->maxCellLength > 3 ? substr($text, 0, $this->maxCellLength-3) : "")."...";
    return $text;
  }

  // These methods should be called (they take editable property into account)

  // Generate code for the HTML input field
  final public function getHtmlInput($params = null) {
    $res = ($this->editable && $this->parent->deadlineOk($this->deadlineDesc) ? $this->htmlInput($params) : $this->htmlOutput($params));
    return (isset($res) ? $res : "");
  }
  // Generate code for the HTML edit field (usually similar to input, with the value added)
  final public function getHtmlEdit($params = null) {
    $res = ($this->editable && $this->parent->deadlineOk($this->deadlineDesc) ? $this->htmlEdit($params) : $this->htmlOutput($params));
    return (isset($res) ? $res : "");
  }
  // Return string to be outputed in HTML page
  final public function getHtmlOutput($params = null) {
    $res = $this->htmlOutput($params);
    return (isset($res) ? $res : "");
  }
  // Return string to be outputed in the table of users
  final public function getHtmlCell($params = null) {
    $res = $this->htmlCell($params);
    return (isset($res) ? $res : "");
  }

  // SQL definition for the field(s) in the main table
  // Returns:
  // - an empty string or null, if no columns are required in the main table, or
  // - a string defining a field (usually named $this->getName()) if a single column is required in the main table, or
  // - an array of strings (described in the previous line) if multiple columns are required in the main table
  abstract public function sqlDefinition();

  // Extra SQL definition(s) to be added after the fields list (i.e., constraints and secondary indexes
  // Returns same stuff as sqlDefinition()
  public function sqlExtraDefinition() {
    return null;
  }

  // SQL code(s) for generating extra table(s)
  // Returns:
  // - an empty string or null, if no extra tables are required, or
  // - an SQL query for creating a table (usually named $this->tableName("something")) if an extra table is required, or
  // - an array of SQL queries (described in the previous line) if multiple extra tables are required
  public function sqlCreateTables() {
    return null;
  }

  // Provide extra form arguments, i.e.,
  // "enctype" => "multipart/form-data"
  // for file upload fields
  // These are merged when the form is generated.
  // Conflicts are not resolved, but the arguments of the later fields overide those of the earlier ones
  public function extraFormArgs() {
    return null;
  }

  // Generate and return CSS code required for this field
  // Can be either a string (a CSS code) or an associative array of form
  // "selector" => "CSS code"
  // to avoid redundancy
  public function cssCode() {
    return "";
  }

  // Generate and return JavaScript code required for this field
  // Can be either a string (a JS code) or an associative array of form
  // "function name" => "JS code"
  // to avoid redundancy
  // The code with the empty "function name", i.e., "" => "JS code", gets merged among codes;
  // for the rest of the codes, only the first definition is used
  public function jsCode() {
    return "";
  }

}

/********************************
 *** Field definition classes ***
 ********************************/

class vsRegsFieldInput extends vsRegsField {

  public function __construct($name, $title = "", $mandatory = false, $htmlParams = null) {
    parent::__construct($name, $title, $mandatory, $htmlParams);
    if (!isset($this->htmlParams["maxlength"])) $this->htmlParams["maxlength"] = 127;
  }

  protected function htmlInput($params = null) {
    $params = (is_array($params) ? array_merge($this->htmlParams, $params) : $this->htmlParams);
    if (!isset($params["type"])) $params["type"] = "text";
    $params["name"] = $this->getName();
    return "<input".$this->htmlParams2str($params)." />";
  }

  protected function htmlEdit($params = null) {
    if (!isset($params["value"]))
      if (is_array($params))
        $params["value"] = $this->getValue();
      else
        $params = array("value" => $this->getValue());
    return $this->htmlInput($params);
  }

  protected function htmlOutput($params = null) {
    return htmlspecialchars($this->getValue());
  }

  public function sqlDefinition() {
    return "`".$this->getName()."` varchar(".$this->htmlParams["maxlength"].") ".$this->sqlDefinitionNull();
  }

}

class vsRegsFieldInputUnique extends vsRegsFieldInput {

  public function sqlExtraDefinition() {
    return "constraint unique (".$this->getName().")";
  }

}

class vsRegsFieldHidden extends vsRegsFieldInput {

  public function __construct($name, $title = "", $mandatory = false, $htmlParams = null) {
    if (!isset($htmlParams["type"])) $htmlParams["type"] = "hidden";
    parent::__construct($name, $title, $mandatory, $htmlParams);
    unset($this->htmlParams["maxlength"]);
    $this->visibleInRegisterBox = false;
    $this->visibleInMembersTable = false;
  }

  protected function htmlOutput($params = null) {
    return "";
  }

  public function sqlDefinition() {
    return "`".$this->getName()."` integer ".$this->sqlDefinitionNull();
  }

}

class vsRegsFieldCaptcha extends vsRegsField {

  public $prepend = "vsRegs: ";

  public function __construct($name, $title = "", $mandatory = false, $htmlParams = null) {
    $mandatory = true;
    parent::__construct($name, $title, $mandatory, $htmlParams);
  }

  public function setDefaultTexts() {
    $this->addText('captchaInvalid', 'Invalid captcha code.');
  }

  public function isVisible($scope = vsRegs::SCOPE_INPUT) {
    return ($scope === vsRegs::SCOPE_INPUT);
  }

  // Make hash -- used when creating captcha
  public function mkhash($text) {
    return md5($this->prepend.$text);
  }

  public function readValueFromPost($scope = vsRegs::SCOPE_INPUT) {
    if ($scope != vsRegs::SCOPE_INPUT) return true;
    $name = $this->getName();
    if (!isset($_POST[$name])) return false;
    if (!isset($_POST[$name."c"])) return false;
    if ($this->mkhash($_POST[$name]) === $_POST[$name."c"]) return true;
    return $this->parent->addError('captchaInvalid');
  }

  protected function htmlInput($params = null) {
    $x = rand(3,11);
    $y = rand(3,11);
    switch (rand(1,3)) {
      case 1: $html = "$x + $y"; $r = $x + $y; break;
      case 2: if ($x < $y) list($x,$y) = array($y,$x); $html = "$x &ndash; $y"; $r = $x - $y; break;
      case 3: $html = "$x &middot; $y"; $r = $x * $y; break;
    }
    return
      $html.
      " = <input type=\"text\" name=\"".$this->getName()."\" size=\"3\" maxlength=\"3\" />".
      "<input type=\"hidden\" name=\"".$this->getName()."c\" value=\"".$this->mkhash($r)."\" />";
  }

  protected function htmlEdit($params = null) {
    return "";
  }

  protected function htmlOutput($params = null) {
    return "";
  }

  public function sqlDefinition() {
    return null;
  }

}

class vsRegsFieldSelect extends vsRegsField {

  protected $values = array(); // should be associative if optgroups are used (i.e., if $values has depth 2)
  public $default = null;

  public function __construct($name, $title = "", $mandatory = false, $htmlParams = null) {
    parent::__construct($name, $title, $mandatory, $htmlParams);
  }

  public function getValues() {
    return $this->values;
  }

  public function setValues($values) {
    foreach ($values as $key => $val)
      if (is_array($val)) {
        foreach ($val as $k => $v)
          if (!is_scalar($v)) return false;
      } else
        if (!is_scalar($val)) return false;
    $this->values = $values;
    return true;
  }

  public function assign($values, $disallow = null) {
    $this->setValues($values);
    $this->disallow = $disallow;
    return $this;
  }

  protected function makeElement($params = null, $selected = null) {
    if (!isset($selected) && isset($this->default)) $selected = $this->default;
    $params = (is_array($params) ? array_merge($this->htmlParams, $params) : $this->htmlParams);
    $name = $this->getName();
    $params = array_merge($params, array("name" => $name));
    $res = "<select".$this->htmlParams2str($params).">";
    foreach ($this->values as $key => $val)
      if (is_array($val)) {
        $res .= "<optgroup label=\"".htmlspecialchars($key)."\">";
        foreach ($val as $k => $v)
          $res .= "<option value=\"".htmlspecialchars($k)."\"".(isset($selected) && $selected == $k ? " selected" : "").">".htmlspecialchars($v)."</option>";
        $res .= "</optgroup>";
      } else
        $res .= "<option value=\"".htmlspecialchars($key)."\"".(isset($selected) && $selected == $key ? " selected" : "").">".htmlspecialchars($val)."</option>";
    $res .= "</select>";
    return $res;
  }

  protected function htmlInput($params = null) {
    return $this->makeElement($params);
  }

  protected function htmlEdit($params = null) {
    return $this->makeElement($params, (isset($this->value) ? $this->value : null));
  }

  protected function htmlOutput($params = null) {
    $key = $this->getValue();
    $val = (isset($this->values[$key]) ? $this->values[$key] : "");
    return htmlspecialchars($val);
  }

  public function sqlDefinition() {
    $maxLen = 0;
    $isAssoc = false;
    foreach ($this->values as $key => $val)
      if (is_array($val))
        foreach ($val as $k => $v) {
          $len = strlen($k);
          if ($maxLen < $len) $maxLen = $len;
          if (strspn($key, "0123456789") < $len) $isAssoc = true;
        }
      else {
        $len = strlen($key);
        if ($maxLen < $len) $maxLen = $len;
        if (strspn($key, "0123456789") < $len) $isAssoc = true;
      }
    return "`".$this->getName()."` ".($isAssoc ? "varchar($maxLen)" : "integer")." ".$this->sqlDefinitionNull();
  }

}

class vsRegsFieldRadio extends vsRegsFieldSelect {

  protected function makeElement($params = null, $selected = null) {
    if (!isset($selected) && isset($this->default)) $selected = $this->default;
    $name = $this->getName();
    $res = "";
    $idx = 0;
    foreach ($this->values as $key => $val) {
      $idx++;
      if (is_array($val)) {
        $res .= "<fieldset><legend>".htmlspecialchars($key)."</legend>";
        foreach ($val as $k => $v)
          $res .= "<input type=\"radio\" name=\"$name\" id=\"$name$idx\" value=\"".htmlspecialchars($k)."\"".(isset($selected) && $selected == $k ? " checked" : "")."><label for=\"$name$idx\">".htmlspecialchars($v)."</label>";
        $res .= "</fieldset>";
      } else
        $res .= "<input type=\"radio\" name=\"$name\" id=\"$name$idx\" value=\"".htmlspecialchars($key)."\"".(isset($selected) && $selected == $key ? " checked" : "")."><label for=\"$name$idx\">".htmlspecialchars($val)."</label>";
    }
    return $res;
  }

}

class vsRegsFieldText extends vsRegsField {

  protected $maxLen = 1719;

  public function __construct($name, $title = "", $mandatory = false, $htmlParams = null) {
    parent::__construct($name, $title, $mandatory, $htmlParams);
    if (!isset($this->htmlParams["maxlength"])) $this->htmlParams["maxlength"] = 127;
  }

  public function getMaxLen() {
    return $this->maxLen;
  }

  public function setMaxLen($maxLen) {
    if (strspn($maxLen, "0123456789") < strlen($maxLen)) return false;
    $this->maxLen = $maxLen;
    return true;
  }

  protected function makeElement($params = null, $value = null) {
    $params = (is_array($params) ? array_merge($this->htmlParams, $params) : $this->htmlParams);
    if (!isset($params["rows"])) $params["rows"] = 5;
    //if (!isset($params["cols"])) $params["cols"] = 47;
    if (!isset($params["style"])) $params["style"] = "width: 100%";
    $params["maxlength"] = 500;
    $params["name"] = $this->getName();
    return "<textarea".$this->htmlParams2str($params).">".(empty($value) ? "" : htmlspecialchars($value))."</textarea>";
  }

  protected function htmlInput($params = null) {
    return $this->makeElement($params);
  }

  protected function htmlEdit($params = null) {
    return $this->makeElement($params, $this->getValue());
  }

  protected function htmlOutput($params = null) {
    return htmlspecialchars($this->getValue());
  }

  // Text fields cannot have default value
  protected function sqlDefinitionNullForText() {
    return ($this->mandatory ? "not null" : "");
  }

  public function sqlDefinition() {
    if ($this->maxLen <= 255)
      $def = "varchar(".$this->maxLen.") ".$this->sqlDefinitionNull();
    if ($this->maxLen <= 65535)
      $def = "text ".$this->sqlDefinitionNullForText();
    if ($this->maxLen <= 16777215)
      $def = "mediumtext ".$this->sqlDefinitionNullForText();
    $def = "longtext ".$this->sqlDefinitionNullForText();
    return "`".$this->getName()."` ".$def;
  }

}

class vsRegsFieldFiles extends vsRegsField {

  public $htmlAdd = "+"; // <img src="images/fileAdd.png" align="top" />
  public $htmlRemove = "&ndash;"; // <img src="images/fileRemove.png" align="top" />
  public $htmlCell = "%d"; // <img src="images/attach.png" title="Number of attachments: %d" />
  public $htmlCellEmpty = "&ndash;";
  public $htmlEmptyList = "&ndash;";

  public function __construct($name, $title = "", $mandatory = false, $htmlParams = null) {
    parent::__construct($name, $title, $mandatory, $htmlParams);
    if (file_exists("images/fileAdd.png"))
      $this->htmlAdd = '<img src="images/fileAdd.png" align="top" />';
    if (file_exists("images/fileRemove.png"))
      $this->htmlRemove = '<img src="images/fileRemove.png" align="top" />';
  }

  public function setParent($parent) {
    parent::setParent($parent);
    if (!isset($this->parent->params["uploadsDir"])) $this->parent->params["uploadsDir"] = "uploads";
    $this->plugin = $parent->addPlugin(new vsRegsPluginFileAttach());
  }

  public function setDefaultTexts() {
    $this->addTexts(array(
      'filesErrorDirConfig' => 'Error with the uploads directory configuration.',
      'filesErrorID' => 'Error obtaining current ID.',
      'filesErrorDir' => 'Error creating uploads directory.',
      'filesErrorSavingData' => 'Error saving uploaded file data.',
      'filesErrorSavingDataDebug' => 'Error saving uploaded file data:<br />{lastPDOerror}.',
      'filesErrorMovingFiles' => 'Error moving uploaded file to the uploads directory.',
      'filesErrorRequest' => 'Error in the upload request.',
      'filesErrorRequestDebug' => 'Error in the upload request:<pre>{files}</pre>',
      'filesErrorMisformated' => 'Misformated upload request.',
      'filesErrorMisformatedDebug' => 'Misformated upload request:<pre>{files}</pre>',
      'filesErrorUploading' => 'Error uploading file.',
      'filesErrorUploadingDebug' => 'Error uploading file:<pre>{files}</pre>',
      'filesHint' => 'Size: {size}&#013;Mime-type: {mime}',
      'filesCheckFilesToDelete' => 'Check the files you want to delete',
      'filesHintAdd' => 'Add file',
      'filesHintRemove' => 'Remove file',
    ));
  }

  public function dataRequiredForDelete() {
    return $this->tableName("files");
  }

  public function deleteData($id = null, $data = null) {
    $tname = $this->tableName("files");
    if (is_array($data) && isset($data[$tname]) && is_array($data[$tname])) {
      $fieldId = $this->parent->params["fieldId"];
      foreach ($data[$tname] as $file)
        @unlink($this->getLocalName($file[$fieldId]));
    }
    return true;
  }

  public function size2str($size = null) {
    $sizes = array("B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB");
    if (!isset($size)) {
      $size = 0;
      if ($this->hasFiles())
        foreach ($this->value["files"] as $file)
          $size += filesize($this->getLocalName($file));
    }
    $idx = 0;
    $last = count($sizes) - 1;
    while ($size >= 1024 && $idx < $last) {
      $size /= 1024;
      $idx++;
    }
    return sprintf("%.2f%s", $size, $sizes[$idx]);
  }

  public function getLocalName($file) {
    $uploadsDir = $this->parent->params["uploadsDir"];
    if (!isset($uploadsDir)) return false;
    if (!empty($uploadsDir)) $uploadsDir .= "/";

    return $uploadsDir.(int)(is_array($file) && isset($file["aid"]) ? $file["aid"] : $file);
  }

  protected function hasFiles() {
    return (is_array($this->value) && isset($this->value["files"]) && is_array($this->value["files"]));
  }

  protected function filesCount() {
    return ($this->hasFiles() ? count($this->value["files"]) : 0);
  }

  protected function addFile($file, &$files = null) {
    if (!isset($file["filename"]) || empty($file["filename"])) return false;
    if (!isset($file["mime"])) return false;
    if (!isset($files)) {
      if (!isset($this->value["files"]) || !is_array($this->value["files"]))
        $this->value["files"] = array();
      $files =& $this->value["files"];
    }
    $files[] = array(
      "aid" => $file[$this->parent->params["fieldId"]],
      "filename" => $file["filename"],
      "mime" => $file["mime"],
    );
    return true;
  }

  public function importValueFromDBrow($row) {
    //echo "<!-- ".print_r($row, true)."\n -->\n";
    $tname = $this->tableName("files");
    $files = array();
    $fid = $this->idx;
    if (is_array($row) && isset($row[$tname]) && is_array($row[$tname]) && $row[$tname])
      foreach ($row[$tname] as $file) {
        if ($file["fid"] == $fid)
          if (!$this->addFile($file, $files)) return false;
      }
    if (!isset($this->value))
      $this->value = array("files" => $files);
    elseif (!isset($this->value["files"]))
      $this->value["files"] = $files;
    elseif (!is_array($this->value["files"]))
      return false;
    else
      $this->value["files"] = array_merge($this->value["files"], $files);
    return true;
  }

  public function tablesToRead() {
    return $this->tableName("files");
  }

  protected function htmlInput($params) {
    $name = $this->getName();
    return '<div id="fld_'.$name.'"><div id="fld_first_'.$name.'" class="file"><input name="'.$name.'[]" type="file"'.$this->htmlParams2str($params).' /> <span style="visibility: hidden;" onClick="return filesRemove(this);" title="Remove file">'.$this->htmlRemove.'</span> <span onClick="return filesAdd(\''.$name.'\', this);" title="Add file">'.$this->htmlAdd.'</span></div></div><script type="text/javascript">makeClone("'.$name.'", "fld_first_'.$name.'"); // --></script><noscript>[Error: JavaScript is disabled]</noscript>';
  }

  protected function htmlListFiles($formNameSuffix = null) {
    if (!$this->hasFiles()) return $this->htmlEmptyList;
    $res = "";
    $files =& $this->value["files"];
    $cnt = count($files);
    $name = $this->getName();
    for ($i = 0; $i < $cnt; $i++) {
      if ($i) $res .= "<br />";
      $file =& $files[$i];
      if (!empty($formNameSuffix))
        $res .= "<input name=\"$name${formNameSuffix}[]\" type=\"checkbox\" value=\"$file[aid]\" />";
      $res .= "<a href=\"?id=".$this->parent->getCurrentId()."&attach=".$file["aid"]."\" title=\"".$this->text('filesHint', array('size' => $this->size2str(@filesize($this->getLocalName($file))), 'mime' => $file["mime"]))."\">".htmlspecialchars($file["filename"])."</a>";
    }
    return $res;
  }

  protected function htmlEdit($params) {
    $name = $this->getName();
    $res = "";
    if ($this->hasFiles())
      $res .= $this->text('filesCheckFilesToDelete').":<br />".$this->htmlListFiles("Del");
    return $res.'<div id="fld_'.$name.'"><div id="fld_first_'.$name.'" class="file"><input name="'.$name.'[]" type="file"'.$this->htmlParams2str($params).' /> <span style="visibility: hidden;" onClick="return filesRemove(this);" title="'.$this->text('filesHintRemove').'">'.$this->htmlRemove.'</span> <span onClick="return filesAdd(\''.$name.'\', this);" title="'.$this->text('filesHintAdd').'">'.$this->htmlAdd.'</span></div></div><script type="text/javascript">makeClone("'.$name.'", "fld_first_'.$name.'"); // --></script><noscript>[Error: JavaScript is disabled]</noscript>';
  }

  protected function htmlOutput($params) {
    //foreach (debug_backtrace() as $trace)
    //  echo "$trace[function] (line $trace[line] in $trace[file])<br>";
    return $this->htmlListFiles();
  }

  protected function htmlCell($params) {
    $cnt = $this->filesCount();
    return ($cnt ? sprintf($this->htmlCell, $cnt) : $this->htmlCellEmpty);
  }

  public function jsCode() {
    return 'var clones = {};

function makeClone(name, el) {
  if (typeof el !== "object")
    el = document.getElementById(el);
  clones[name] = el.cloneNode(true);
}

function filesAdd(name, el) {
  var line = el.parentNode;
  var container = line.parentNode;
  var clone = clones[name].cloneNode(true);
  clone.children[1].style.visibility = "visible";
  container.appendChild(clone);
  line.children[2].style.visibility = "hidden";
  if (container.children.length == 2)
    container.children[0].children[1].style.visibility = "visible";
}

function filesRemove(el) {
  var line = el.parentNode;
  var container = line.parentNode;
  container.removeChild(line);
  if (container.children.length == 1)
    container.children[0].children[1].style.visibility = "hidden";
  container.children[container.children.length-1].children[2].style.visibility = "visible";
}';
  }

  public function getCellParams() {
    return ($this->filesCount() ? array("class" => "attach") : null);
  }

  // Data will be saved to the separate table, to allow more than one vsRegsFieldFile* field per record
  // Used keys are parent's getCurrentId and the field's $idx
  public function sqlDefinition() {
    return false;
  }

  public function requiredTables() {
    return array($this->tableName("files"));
  }

  public function sqlCreateTables() {
    return "create table ".$this->tableName("files")." (`".$this->parent->params["fieldId"]."` integer auto_increment primary key, ".$this->parent->params["fieldPid"]." integer not null, fid integer not null, filename varchar(255) not null, mime varchar(255)) default charset=utf8 collate=utf8_bin";
  }

  public function exportValueToDBrow() {
    return null;
  }

  public function extraFormArgs() {
    return array(
      "enctype" => "multipart/form-data",
    );
  }

  protected function deleteFiles($aids = null) {
    if (!isset($aids)) $aids = $this->value["deleted"];
    if (!is_array($aids) || !count($aids)) return true;
    $sql = "";
    foreach ($aids as $aid)
      $sql .= ($sql ? "," : "")."'".(int)$aid."'";
    $sql = "delete from ".$this->tableName("files")." where id in ($sql)";
    $sth = $this->query($sql);
    if (!isset($sth) || $sth->errorCode() != '00000') return false;
    foreach ($aids as $aid)
      @unlink($this->getLocalName($aid));
    return true;
  }

  protected function uploadFiles($uploaded = null) {
    if (!isset($uploaded)) $uploaded = $this->value["uploaded"];
    if (!is_array($uploaded) || !count($uploaded)) return true;

    $uploadsDir = $this->parent->params["uploadsDir"];
    if (!isset($uploadsDir)) return $this->parent->addError('filesErrorDirConfig');
    $currentId = $this->parent->getCurrentId();
    if (empty($currentId)) return $this->parent->addError('filesErrorID');
    $fieldPid = $this->parent->params["fieldPid"];
    $fieldId = $this->parent->params["fieldId"];
    $fid = $this->idx;
    $finfo = new finfo(FILEINFO_MIME);
    $tname = $this->tableName("files");

    if (!empty($uploadsDir) && !is_dir($uploadsDir))
      if (!mkdir(
        $uploadsDir,
        isset($this->parent->params["uploadsDirMode"]) ? $this->parent->params["uploadsDirMode"] : 0755,
        true
      )) return $this->parent->addError('filesErrorDir');

    foreach ($uploaded as $upload) {
      $mime = preg_replace('#;.*$#', "", $finfo->file($upload["tmp_name"]));
      $sth = $this->query("insert into $tname set $fieldPid=:pid, fid=:fid, filename=:filename, mime=:mime", array(
        "pid" => $currentId,
        "fid" => $fid,
        "filename" => $upload["name"],
        "mime" => $mime,
      ));
      if (!isset($sth) || $sth->errorCode() != '00000')
        return $this->parent->addError('filesErrorSavingDataDebug');
      $aid = $this->dbh->lastInsertId($fieldId);
      if (!move_uploaded_file($upload["tmp_name"], $this->getLocalName($aid))) {
        $this->query("delete from $tname where $fieldId=$aid");
        return $this->parent->addError('filesErrorMovingFiles');
      }
      $this->addFile(array(
        $fieldId => $aid,
        "filename" => $upload["name"],
        "mime" => $mime,
      ));
    }
    return true;
  }

  // Taken from http://stackoverflow.com/questions/173400/php-arrays-a-good-way-to-check-if-an-array-is-associative-or-numeric
  public function isAssoc($array) {
    return (bool)count(array_filter(array_keys($array), 'is_string'));
  }

  public function valueFromArrayOrScalar($var, $idx) {
    return (is_array($var) ? $var[$idx] : $var);
  }

  public function readValueFromPost($scope = vsRegs::SCOPE_INPUT) {
    $name = $this->getName();
    $hasFiles = $this->hasFiles();

    // Get the attachment IDs of the files that will be deleted
    if (isset($_POST["${name}Del"]) && $_POST["${name}Del"]) {
      $aids = array();
      foreach ((array)$_POST["${name}Del"] as $aid)
        $aids[] = (int)$aid;
      $this->value["deleted"] = $aids;
    }

    // Get the data for the uploaded file(s)
    if (isset($_FILES[$name]) && is_array($_FILES[$name])) {

      $files =& $_FILES[$name];
      if (!(isset($files["name"]) && isset($files["size"]) && isset($files["tmp_name"]) && isset($files["error"])))
        return $this->parent->addError('filesErrorRequest', array('files' => print_r($files, true)));

      $cnt = count((array)$files["name"]);
      foreach ($files as $key => &$val)
        if ($cnt != count((array)$val))
          return $this->parent->addError('filesErrorMisformated', array('files' => print_r($files, true)));

      $uploaded = array();
      for ($i = 0; $i < $cnt; $i++) {

        // Skip nonexistent uploads
        $fname = $this->valueFromArrayOrScalar($files["name"], $i);
        $tmpname = $this->valueFromArrayOrScalar($files["tmp_name"], $i);
        if (empty($fname) && empty($tmpname)) continue;

        // Check for upload errors
        $err = $this->valueFromArrayOrScalar($files["error"], $i);
        if ($err != UPLOAD_ERR_OK)
          return $this->parent->addError('filesErrorUploading', array('files' => "$i ($err): ".print_r($files, true)));

        // Rearange keys
        $upload = array();
        foreach ($files as $key => &$val)
          $upload[$key] = $this->valueFromArrayOrScalar($val, $i);

        // Add file
        $uploaded[] = $upload;
      }
      $this->value["uploaded"] = $uploaded;
    }
    return true;
  }

  public function insertData() {
    return $this->editData();
  }

  public function editData() {
    if (isset($this->value["deleted"]) && $this->value["deleted"]) {
      if (!$this->deleteFiles()) return false;
      unset($this->value["deleted"]);
    }
    if (isset($this->value["uploaded"]) && $this->value["uploaded"]) {
      if (!$this->uploadFiles()) return false;
      unset($this->value["uploaded"]);
    }
    return true;
  }

}

class vsRegsFieldFile extends vsRegsFieldFiles {

  public $replaceLabel = "Replace";
  public $cancelLabel = "Cancel";

  public function size2str($size = null) {
    if (!isset($size)) {
      $file = $this->getFile();
      if (!$file) return "&ndash;";
      $size = @filesize($this->getLocalName($file));
    }
    return parent::size2str($size);
  }

  protected function getFile() {
    if (!isset($this->value) || !isset($this->value["files"]) || !is_array($this->value["files"])) return false;
    if (count($this->value["files"]) != 1) return false;
    return $this->value["files"][0];
  }

  public function getLocalName($file = null) {
    if (!isset($file)) {
      $file = $this->getFile();
      if (!$file) return false;
    }
    return parent::getLocalName($file);
  }

  protected function htmlInput($params = null) {
    $params = (is_array($params) ? array_merge($this->htmlParams, $params) : $this->htmlParams);
    if (!isset($params["type"])) $params["type"] = "file";
    $params["name"] = $this->getName();
    return "<input".$this->htmlParams2str($params)." />";
  }

  protected function htmlEdit($params = null) {
    $file = $this->getFile();
    if (!$file) return $this->htmlInput($params);
    $name = $this->getName();
    $aid = (int)$file["aid"];
    return "<input type=\"hidden\" name=\"${name}Del\" id=\"${name}Del\" value=\"\" /><span id=\"${name}Orig\" style=\"display: inline;\">".$this->getHtmlOutput()." <button onClick=\"document.getElementById('${name}Orig').style.display = 'none'; document.getElementById('${name}Replace').style.display = 'inline'; document.getElementById('${name}Del').value = $aid; return false;\">".$this->replaceLabel."</button></span><span id=\"${name}Replace\" style=\"display: none;\">".$this->htmlInput($params)." <button onClick=\"document.getElementById('${name}Orig').style.display = 'inline'; document.getElementById('${name}Replace').style.display = 'none'; document.getElementById('${name}Del').value = ''; return false;\">".$this->cancelLabel."</button></span>";
  }

  protected function htmlOutput($params = null) {
    $file = $this->getFile();
    return ($file ? "<a href=\"?id=".$this->parent->getCurrentId()."&attach=".$file["aid"]."\" title=\"".$this->text('filesHint', array('size' => $this->size2str(), 'mime' => $file["mime"]))."\">".htmlspecialchars($file["filename"])."</a>" : "&ndash;");
  }

  protected function htmlCell($params = null) {
    $file = $this->getFile();
    return ($file ? htmlspecialchars($file["filename"])." [".$this->size2str()."]" : "&ndash;");
  }

  public function readValueFromPost($scope = vsRegs::SCOPE_INPUT) {
    $res = parent::readValueFromPost($scope);
    if (!$res) return false;
    if (
        (!isset($this->value["deleted"]) || count((array)$this->value["deleted"]) < 1) // Nothing to delete
        && isset($this->value["uploaded"]) && count((array)$this->value["uploaded"]) // But something to upload
        && $this->getFile() // While we already have something uploaded
      ) {
        // It means that the user has picked the upload, but canceled it (hiding the file field)
        // So, we don't want upload(s)
        unset($this->value["uploaded"]);
      }
    if (isset($this->value["uploaded"]) && @count($this->value["uploaded"]) > 1) {
      // In case someone misformed the POST request, deny more than one upload
      unset($this->value["uploaded"]);
    }
    return true;
  }

}

class vsRegsFieldAvatar extends vsRegsFieldFile {

  public $maxWidth = 100;
  public $maxHeight = 150;
  public $maxCellWidth = 64;
  public $maxCellHeight = 32;
  public $css = "avatar";

  protected function mkThumb($maxWidth, $maxHeight, $params) {
    $file = $this->getFile();
    if (!$file) return null;
    if (!isset($file["mime"]) || empty($file["mime"])) return parent::htmlOutput($params);
    $fn = $this->getLocalName();
    if (empty($fn) || !file_exists($fn)) return parent::htmlOutput($params);
    $im = getImageSize($fn);
    if ($im === false) return parent::htmlOutput($params);
    $mime = preg_replace('#;.*$#', "", $file["mime"]);
    list($w, $h) = $im;
    if ($w > $maxWidth || $h > $maxHeight) {
      $fw = $w / $maxWidth;
      $fh = $h / $maxHeight;
      $f = max($fw, $fh);
      $thumb = new Imagick();
      $thumb->readImage($fn);
      $thumb->resizeImage($w = round($w / $f), $h = round($h / $f), Imagick::FILTER_LANCZOS, 1);
      //if (!$thumb->setImageFormat($mime)) return parent::htmlOutput($params);
      $res = $thumb->getImageBlob();
      $thumb->destroy();
    } else
      $res = file_get_contents($fn);
    return "<img width=\"$w\" height=\"$h\"".(empty($this->css) ? "" : " class=\"".$this->css."\"")." src=\"data:$mime;base64,".base64_encode($res)."\" />";
  }

  protected function htmlOutput($params) {
    $file = $this->getFile();
    if (!$file) return parent::htmlOutput($params);
    $thumb = $this->mkThumb($this->maxWidth, $this->maxHeight, $params);
    if (isset($thumb))
      return "<a href=\"?id=".$this->parent->getCurrentId()."&attach=".$file["aid"]."\" title=\"".$this->text('filesHint', array('size' => $this->size2str(), 'mime' => $file["mime"]))."\">$thumb</a>";
    return $this->htmlInput($params);
  }

  public function getCellParams() {
    $file = $this->getFile();
    return ($file ? array("title" => $this->text('filesHint', array('size' => $this->size2str(), 'mime' => $file["mime"]))) : null);
  }

  protected function htmlCell($params) {
    return $this->mkThumb($this->maxCellWidth, $this->maxCellHeight, $params);
  }

}

/**********************
 *** Plugin classes ***
 **********************/

class vsRegsPlugin extends vsRegsBasic {

  protected $parent = null;

  public function setParent($parent) {
    $this->parent = $parent;
    $this->catchPDOException =& $this->parent->catchPDOException;
    $this->breakOnBindErrors =& $this->parent->breakOnBindErrors;
    $this->lastPDOerrorInfo =& $this->parent->lastPDOerrorInfo;
    $this->dbh =& $this->parent->dbh;
    $this->setDefaultTexts();
  }

  public function addText($code, $text) {
    $this->parent->addText($code, $text);
  }

  public function addTexts($texts) {
    $this->parent->addTexts($texts);
  }

  public function text($text, $params = null) {
    return $this->parent->text($text, $params);
  }

  // If true, only one plugin of that class can be added to vsRegs object
  // If you try to add another, nothing will happen
  // vsRegs::addPlugin() returns the reference to the added plugin or,
  // if it wasn't added, to the already existing one
  public function unique() {
    return false;
  }

  public function tableName($name) {
    if (isset($this->parent) && $this->parent instanceof vsRegs)
      return $this->parent->tableName($name);
    return false;
  }

  // Generate and return CSS rules required by this plugin
  // Return values are as described in vsRegsField
  public function cssCode() {
    return "";
  }

  // Generate and return JavaScript code required by this plugin
  // Return values are as described in vsRegsField
  public function jsCode() {
    return "";
  }

  public function beforeAttendInsert() { return ""; }
  public function beforeAttendUpdate() { return ""; }
  public function afterAttendInsert() { return ""; }
  public function afterAttendUpdate() { return ""; }

  public function beforeExtraInsert($tname) { return ""; }
  public function beforeExtraUpdate($tname) { return ""; }
  public function afterExtraInsert($tname) { return ""; }
  public function afterExtraUpdate($tname) { return ""; }

  public function beforeMembersTable($memberList) { return ""; }
  public function beforeMembersTableRow($row) { return ""; }
  public function beforeMembersTableCell($field) { return ""; }
  public function afterMembersTableCell($field) { return ""; }
  public function afterMembersTableRow($row) { return ""; }
  public function afterMembersTable($memberList) { return ""; }

  public function beforeRegisterBox($scope) { return ""; }
  public function afterRegisterBox($scope) { return ""; }
  public function registerBoxHead($scope) { return ""; }
  public function registerBoxFoot($scope) { return ""; }

  // These accept: array($scope, $field)
  public function beforeRegisterBoxField($params) { return ""; }
  public function beforeRegisterBoxFieldTitle($params) { return ""; }
  public function afterRegisterBoxFieldTitle($params) { return ""; }
  public function beforeRegisterBoxFieldData($params) { return ""; }
  public function afterRegisterBoxFieldData($params) { return ""; }
  public function afterRegisterBoxField($params) { return ""; }

  public function beforeHandleRequests() { return ""; }
  public function afterHandleRequests() { return ""; }

  // These return true for success
  public function clearValues() { return true; } // Return value has no effect at the moment, but may have it in some class inheriting vsRegs
  public function clearFieldValue($field) { return true; } // Return value has no effect at the moment, but may have it in some class inheriting vsRegs
  public function processImportedData($field) { return true; } // Return value has no effect at the moment, but may have it in some class inheriting vsRegs
  public function preprocessPostedData($params) { return true; } // true = go on with the import; false = skip importing data; $params = array($scope, $field)
  public function postprocessPostedData($params) { return true; } // true = success; false = report error

  // Execute bulk action
  // Arguments are action string and the array of selected IDs
  public function bulkAction($params) { return ""; }

}

class vsRegsPluginFileAttach extends vsRegsPlugin {

  public function unique() {
    return true;
  }

  public function setParent($parent) {
    parent::setParent($parent);
    if (!isset($this->parent->params["uploadsDir"])) $this->parent->params["uploadsDir"] = "uploads";
  }

  public function setDefaultTexts() {
    $this->addTexts(array(
      'downloadError' => 'Database read error. Please, try again later.',
      'downloadErrorDebug' => 'Database read error:<br />{lastPDOerror}',
      'downloadNoAttachment' => 'Attachment doesn\'t exist.',
    ));
  }

  public function download($userId, $attachId) {
    $userId = (int)$userId;
    $attachId = (int)$attachId;
    $sth = $this->query(
      "select * from ".$this->tableName("files")." where id=:attachId and ".$this->parent->params["fieldPid"]."=:userId",
      array(
        "attachId" => $attachId,
        "userId" => $userId,
      )
    );
    if (!$sth) $this->parent->addError('downloadError');
    $row = $sth->fetch();
    if (!$row) $this->parent->addError('downloadNoAttachment');
    $uploadsDir = $this->parent->params["uploadsDir"];
    if (!empty($uploadsDir)) $uploadsDir .= "/";
    $localName = $uploadsDir.$row[$this->parent->params["fieldId"]];
    if (!empty($row["mime"])) header("Content-type: $row[mime]");
    header("Content-Disposition: attachment; filename=\"$row[filename]\"");
    header("Pragma: public");
    header("Cache-Control: must-revalidate, post-check=0, pre-check=0");
    header("Content-Length: ".filesize($localName));
    readfile($localName);
    exit(0);
  }

  public function beforeHandleRequests() {
    if (!(empty($_GET["id"]) || empty($_GET["attach"])))
      $this->download($_GET["id"], $_GET["attach"]);
    return "";
  }

}

class vsRegsPluginAutoRegInfo extends vsRegsPlugin {

  protected $userData = null;
  public $messageWithData = "";
  public $messageWithoutData = "";
  public $mapping = array(); // fieldName => userDataKey

  public function assign(&$userData, $messageWithData = "", $messageWithoutData = "") {
    $this->userData =& $userData;
    $this->messageWithData = $messageWithData;
    $this->messageWithoutData = $messageWithoutData;
    return $this;
  }

  public function assignMap($fieldName, $udKey) {
    $this->mapping[$fieldName] = $udKey;
    return $this;
  }

  public function assignMapping($map, $resetOld = false) {
    if ($resetOld)
      $this->mapping = $map;
    else
      $this->mapping = array_merge($this->mapping, $map);
    return $this;
  }

  public function userData($fieldName) {
    if (is_array($this->mapping) && isset($this->mapping[$fieldName]))
      return $this->userData[$this->mapping[$fieldName]];
    return (isset($this->userData[$fieldName]) ? $this->userData[$fieldName] : null);
  }

  // Some header info, usually a warning to log off or log in
  public function registerBoxHead($scope) {
    if ($scope != vsRegs::SCOPE_INPUT) return "";
    return (isset($this->userData) ? $this->messageWithData : $this->messageWithoutData);
  }

  public function preprocessPostedData($params) {
    if (!isset($this->userData)) return true;
    list($scope, $field) = $params;
    if ($scope !== vsRegs::SCOPE_INPUT) return true;
    $val = $this->userData($field->getName());
    if (!isset($val)) return true;
    $field->setValue($val);
    $field->editable = false;
    return false;
  }

  public function beforeRegisterBoxFieldData($params) {
    $this->preprocessPostedData($params);
    return "";
  }

}

/**********************
 *** The main class ***
 **********************/

class vsRegs extends vsRegsBasic {

  const ROLE_USER = 0;
  const ROLE_LIST = 1;
  const ROLE_VIEW = 2;
  const ROLE_EDIT = 4;
  const ROLE_CONFIRM = 8;
  const ROLE_DOWNLOAD = 16;
  const ROLE_DELETE = 32;
  const ROLE_ADMIN = PHP_INT_MAX;

  const SCOPE_INPUT = 1;
  const SCOPE_EDIT = 2;
  const SCOPE_OUTPUT = 4;
  const SCOPE_TABLE = 8;

  public $params = array(
    "bulkCSS" => "bulk", // CSS class for the bulk action fields (th, td, div)
    "code" => "", // Identifying code for the event; if provided, main table will be called code_attend
    "debug" => false, // Set to true to get more detailed error messages
    "deadline: Registration" => null, // "deadline: *" defines deadline for certain events
                                      // Preferable use is via addDeadline and deadlineOk/deadlinePassed methods
    "dropIfExists" => true, // When creating tables, drop the old ones if they exist
    "extraDefs" => "", // Extra SQL definitions (i.e., constraints and indexes) in creation of the main table
    "fieldPid" => "pid", // Name of the parent ID field in tables
    "fieldId" => "id", // Name of the ID field in tables (primary key, autoincrement)
    "formAction" => null, // Use in action field of a registration form
    "formatDateOnly" => "j/n/Y.", // Date format when only date is needed
    "formatDateWithTime" => "j/n/Y, H:i (T)", // Date format when time is included as well
    "infoLegend" => "", // Legend, desplayed before form fields when displaying data
    "mandatoryMark" => "<span class=\"mandatory\" title=\"Mandatory field\">&#42</span>", // Label for mandatory fields
    "membersCSS" => "members", // CSS class for the members table
    "membersId" => null, // ID for the members table
    "membersTableSelectExtra" => "", // Extra select requirements for the members table (HTML; does not affect retrieved data)
    "registrationCSS" => "registration", // CSS class for the registration form elements
  );
  public $texts = array(); // translations array
  public $autoHandled = false; // set to true when the POST/GET requests are handled automatically
  protected $fields = array(); // array of fields
  protected $plugins = array(); // array of plugins
  protected $additionalBulkActions = array( // array of bulk actions (additionally filled and handled by plugins)
    "delete" => array("Delete", vsRegs::ROLE_DELETE),
  );
  protected $name2field = array(); // map name => plugin
  public $currentId = null; // ID of the currently loaded data (not always available)
  protected $currentData = null; // data of the currently loaded member (not always available)
  protected $currentDataLoaded = false; // is any member's data loaded at the moment
  protected $msgErrors = array(); // array of error messages
  protected $msgInfos = array(); // array of info messages
  protected $role = vsRegs::ROLE_USER; // current role (should be on top of $roles, but this works a bit faster)
  protected $roles = array(); // stack of previous roles

  function __construct($params) {

    $this->params["formAction"] = $_SERVER["PHP_SELF"];

    foreach ($params as $key => &$val)
      if ($key === "role") // Set role
        $this->role = $val;
      elseif ($key === "dbh") // Set database handler (PDO object handler)
        $this->dbh =& $val;
      elseif ($key === "fields") // Load fields
        foreach ($val as $field)
          $this->addField($field);
      elseif ($key === "plugin" || $key === "plugins") // Load plugin(s)
        foreach ((array)$val as $plugin)
          $this->addPlugin($plugin);
      elseif (substr($key, 0, 9) === "deadline:") // Set deadline
        $this->addDeadline(substr($key, 9), $val);
      else // Set any other parameter
        $this->params[$key] = $val;

    $this->setDefaultTexts(); // Load default language (override this method for translations)

    // Set default legends and title (from the language data),
    // unless they were defined in params (as "", if you want to remove them)
    foreach (array('editLegend', 'infoLegend', 'registrationLegend', 'editTitle', 'infoTitle', 'registrationTitle') as $param)
      if (!isset($this->params[$param]))
        $this->params[$param] = $this->text($param, array('mandatoryMark' => $this->params["mandatoryMark"]));
  }

  // When making a translation, it is best to override this method,
  // WITHOUT calling this one from the parent class, to save on redundancy
  public function setDefaultTexts() {
    $this->addTexts(array(
      // Bulk
      'admin' => 'Admin',
      'bulkCheckHint' => 'Mark for the bulk action',
      'bulkActionsLabel' => 'Bulk actions (for the selected members)',
      'bulkNone' => 'Select',
      'bulkExecute' => 'Execute',
      'bulkNoAction' => 'You didn\'t choose the action.',
      // Deadlines
      'deadline: Registration' => 'Registration',
      'deadline: Abstract submission' => 'Abstract submission',
      'deadline: Poster submission' => 'Poster submission',
      'deadline: Abstract and poster submission' => 'Abstract and poster submission',
      // Errors
      'errorNotField' => 'Field must be an instance of vsRegsField.',
      'errorFieldExists' => 'Field with the name "{name}" already exists.',
      'errorWrongIndex' => 'Wrong index value: {idx}.',
      'errorNoFieldWithName' => 'No field exists with a name "{name}".',
      'errorFailedSet' => 'Failed to set value for field "{name}".',
      'errorDrop' => 'Error dropping tables {tables}.',
      'errorCreatingAttendanceTable' => 'Error creating attendance table.',
      'errorCreatingAttendanceTableDebug' => 'Error creating attendance table using the SQL query<pre>{sql}</pre>',
      'errorCreatingExtraTables' => 'Error creating extra tables.',
      'errorCreatingExtraTablesDebug' => 'Error creating extra tables for the field "{name}", using the SQL query<pre>{sql}</pre>',
      'errorNotUnique' => 'The application with the similar data already exists.',
      'errorSavingAttendanceData' => 'Error saving the attendance data.',
      'errorSavingAttendanceDataDebug' => 'Error saving the attendance data using the SQL query<pre>{sql}</pre>and input data<pre>{values}</pre>The PDO error info:<br />{lastPDOerror}',
      'errorFailedInsertDataDebug' => 'Failed with insertData() for the field "{name}".',
      'errorFailedEditDataDebug' => 'Failed with editData() for the field "{name}".',
      'errorFailedAfterInsertDebug' => 'Failed with afterInsert() for the field "{name}".',
      'errorFailedAfterEditDebug' => 'Failed with afterEdit() for the field "{name}".',
      'errorGettingIDs' => 'Error getting IDs.',
      'errorGettingMembersData' => 'Error getting members\' data.',
      'errorDeletingExtraData' => 'Error deleting extra data for user {user} and field "{name}".',
      'errorDeletingMembersData' => 'Error deleting members\' data from table "{tname}".',
      'errorFieldInvalidDataDebug' => 'Field "{name}" has invalid data.',
      'errorFieldsInvalidDataDebug' => 'Field {names} has invalid data.',
      'errorFetchAttendant' => 'Error fetching attendants\' data.',
      'errorFetchData' => 'Error fetching attendants\' data from table "{tname}".',
      // Infos
      'successInsert' => 'Registration was successful.',
      'successUpdate' => 'Data was successfully changed.',
      'successDelete' => 'Members were successfully deleted.',
      // Other
      'editLegend' => 'Fields marked by {mandatoryMark} are mandatory.',
      'editTitle' => 'Edit data',
      'goBack' => 'Please, go <a href="#" onClick="history.back(); return false;">back</a> and edit your data.',
      'infoLegend' => '',
      'infoTitle' => 'Info',
      'notScalar' => 'Not scalar',
      'registrationLegend' => 'Fields marked by {mandatoryMark} are mandatory.',
      'registrationTitle' => 'Registration',
      'resetFields' => 'Reset all fields',
      'submit' => 'Submit',
    ));
  }

  public function addText($code, $text) {
    $this->texts[$code] = $text;
  }

  public function addTexts($texts) {
    foreach ($texts as $code => $text)
      $this->addText($code, $text);
  }

  // Default params; intended for easier debugging
  public function defaultTextParams() {
    return ($this->params["debug"] ?
      array(
        'lastPDOerror' => 'Error ('.$this->lastPDOerrorInfo[0].'-'.$this->lastPDOerrorInfo[1].'): '.$this->lastPDOerrorInfo[2],
      ) : array(
      )
    );
  }

  public function text($text, $params = null) {
    if ($this->params["debug"] && isset($this->texts[$text."Debug"])) $text .= "Debug";
    if (isset($this->texts[$text])) {
      // Pick a text from the central repository
      $text = $this->texts[$text];
      $iter = 0;
      while ($iter++ < 17 && isset($this->texts['{'.$text.'}']))
        $text = $this->texts['{'.$text.'}'];
    } else
      return "";

    // Add defaults (unless $params is scalar!)
    if (!isset($params))
      $params = $this->defaultTextParams();
    elseif (is_array($params))
      $params = array_merge($this->defaultTextParams(), $params);

    if (is_array($params)) {
      // Replace each {$key} string with $params[$key]
      $iter = 0;
      do {
        $old = $text;
        foreach ($params as $code => $val) {
          if (is_array($val)) {
            $val = array_map(create_function('$val', 'return "\"".htmlspecialchars($val)."\"";'), $val);
            $val = implode(", ", array_slice($val, 0, -1))." and ".$val[count($val)-1];
          }
          $text = str_replace('{'.$code.'}', $val, $text);
        }
      } while (++$iter < 17 && $old != $text);
    } elseif (isset($params)) {
      // In case of a string, substitute ALL {code} strings with $params
      $iter = 0;
      do {
        $old = $text;
        $text = preg_replace('#{\w+}#', $params, $text);
      } while (++$iter < 17 && $old != $text);
    }
    return $text;
  }

  public function runPlugins($func, $arg = null) {
    $res = "";
    if (isset($arg)) {
      foreach ($this->plugins as $plugin)
        if (method_exists($plugin, $func))
          $res .= $plugin->$func($arg);
    } else {
      foreach ($this->plugins as $plugin)
        if (method_exists($plugin, $func))
          $res .= $plugin->$func();
    }
    return $res;
  }

  public function clearInfos() {
    $this->msgInfos = array();
  }

  public function clearErrors() {
    $this->msgErrors = array();
  }

  public function clearMessages() {
    $this->clearErrors();
    $this->clearInfos();
  }

  public function errors() {
    return $this->msgErrors;
  }

  public function infos() {
    return $this->msgInfos;
  }

  public function addErrorPlain($msg) {
    if (!empty($msg)) $this->msgErrors[] = $msg;
    return false;
  }

  public function addError($msgCode, $params = null) {
    return $this->addErrorPlain($this->text($msgCode, $params));
  }

  public function addInfoPlain($msg) {
    $this->msgInfos[] = $msg;
    return true;
  }

  public function addInfo($msgCode, $params = null) {
    return $this->addInfoPlain($this->text($msgCode, $params));
  }

  public function grantRole($role) {
    $this->roles[] = $this->role;
    $this->role |= $role;
  }

  public function revokeRole($role = vsRegs::ROLE_ADMIN) {
    $this->roles[] = $this->role;
    $this->role &= $role;
  }

  public function setRole($role = vsRegs::ROLE_USER) {
    $this->roles[] = $this->role;
    $this->role = $role;
  }

  public function unsetRole() {
    if ($this->roles)
      $this->role = array_pop($this->roles);
    return $this->role;
  }

  public function resetRole() {
    if ($this->roles) {
      $this->role = $this->roles[0];
      $this->roles = array();
    }
    return $this->role;
  }

  // Does program have the role $role
  // If $role is an array, does it have any of the roles in it?
  // Subarrays are treated with hasRoles()
  public function hasRole($role) {
    if (is_array($role)) {
      foreach ($role as $r)
        if ($this->hasRoles($r)) return true;
      return false;
    }
    return (($this->role & $role) == $role ? true : false);
  }

  // Does program have the role $role
  // If $role is an array, does it have all of the roles in it?
  // Subarrays are treated with hasRole()
  public function hasRoles($role) {
    if (is_array($role)) {
      foreach ($role as $r)
        if (!$this->hasRoles($r)) return false;
      return false;
    }
    return (($this->role & $role) == $role ? true : false);
  }

  // Check permissions
  // To get true, either of the roles must be had
  // In addition, deadline must not have passed if the role is not $superRole
  public function canDo($deadlineDesc, $role, $superRole = vsRegs::ROLE_ADMIN) {
    if ($this->hasRole($superRole)) return true;
    if ($this->deadlinePassed($deadlineDesc)) return false;
    return $this->hasRole($role);
  }

  // Add deadline with name $name (i.e., "Registration") and date $date.
  // $date can be null (no deadline), timestamp or string in "yyyy-mm-dd" or "yyyy-mm-dd hh:mm" format.
  // Returns true on success and false on failure (unrecognized input format).
  public function addDeadline($name, $date = null) {
    if (empty($name)) return false;
    $name = trim($name);
    if (!isset($date))
      $this->params["deadline: $name"] = null;
    elseif (is_int($date))
      $this->params["deadline: $name"] = $date;
    elseif (preg_match('#^\s*(\d{4})\s*-\s*(\d{1,2})\s*-\s*(\d{1,2})\s*$#', $date, $reOut))
      $this->params["deadline: $name"] = mktime(24, 0, 0, (int)$reOut[2], (int)$reOut[3], (int)$reOut[1]);

    elseif (preg_match('#^\s*(\d{4})\s*-\s*(\d{1,2})\s*-\s*(\d{1,2})\s+(\d{1,2})\s*:\s*(\d{1,2})\s*$#', $date, $reOut))
      $this->params["deadline: $name"] = mktime((int)$reOut[4], (int)$reOut[5], 0, (int)$reOut[2], (int)$reOut[3], (int)$reOut[1]);
    else
      return false;
    return true;
  }
  
  public function deadlineOk($name) {
    return (!isset($this->params["deadline: $name"]) || $this->params["deadline: $name"] >= time());
  }
  
  public function deadlinePassed($name) {
    return (isset($this->params["deadline: $name"]) && $this->params["deadline: $name"] < time());
  }
  
  public function deadline2str($name, $noDeadlineText = "&ndash;") {
    if (!isset($this->params["deadline: $name"]) || !is_int($this->params["deadline: $name"]))
      return $noDeadlineText;
    $date = $this->params["deadline: $name"];
    $min = (int)date("i", $date);
    $hour = (int)date("G", $date);
    if ($min == 0 && $hour == 0)
      return date($this->params["formatDateOnly"], $date - 1);
    else
      return date($this->params["formatDateWithTime"], $date);
  }

  public function deadlinesStrings($noDeadlineText = "&ndash;") {
    $res = array();
    foreach ($this->params as $key => $val)
      if (substr($key, 0, 10) === "deadline: ") {
        $name = substr($key, 10);
        $res[$name] = $this->deadline2str($name, $noDeadlineText);
      }
    return $res;
  }

  public function generateDeadlinesBox($noDeadlineText = "&ndash;") {
    $res = "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"deadlines\">\n";
    foreach ($this->deadlinesStrings() as $name => $deadline) {
      $res .= "  <tr><td class=\"deadlineName\">".$this->text("deadline: $name").":</td><td class=\"deadlineDate\">$deadline</td></tr>\n";
    }
    $res .= "</table>\n";
    return $res;
  }

  public function getCurrentId() {
    return $this->currentId;
  }

  public function loadMemberData($id) {
    $this->clearValues();
    $data = $this->membersInfo(true, (int)$id);
    if ($data) {
      $this->currentDataLoaded = true;
      $this->currentData = $data[0];
      $this->currentId = (int)$id;
      $this->importValuesFromDBrow($data[0]);
    } else {
      $this->currentDataLoaded = false;
      $this->currentData = null;
      $this->currentId = null;
    }
    return $this->currentData;
  }

  public function setCurrentData($data) {
    $fieldId = $this->params["fieldId"];
    $this->currentData = $data;
    $this->currentId = (isset($data) && isset($data[$fieldId]) && !empty($data[$fieldId]) ? $data[$fieldId] : null);
    $this->currentDataLoaded = true;
    return $this->currentData;
  }

  public function getCurrentData() {
    if (empty($this->currentId)) return null;
    if (!$this->currentDataLoaded) {
      $this->loadMemberData((int)$this->currentId);
      $this->currentDataLoaded = true;
    }
    return $this->currentData;
  }

  public function getFieldsCount() {
    return count($this->fields);
  }

  public function getField($idx) {
    $idx = (int)$idx;
    if ($idx < 0 || $idx >= $this->getFieldsCount()) return null;
    return $this->fields[$idx];
  }

  public function getFieldByName($name) {
    return (isset($this->name2field[$name]) ? $this->name2field[$name] : null);
  }

  public function getFieldIndexByName($name) {
    foreach ($this->fields as $idx => $field)
      if ($field->getName() === $name) return $idx;
    return -1;
  }

  public function addField($field) {
    if (!($field instanceof vsRegsField)) $this->addError('errorNotField');
    $name = $field->getName();
    $existing = $this->getFieldByName($name);
    if (isset($existing)) $this->addError('errorFieldExists', array('name' => $name));
    $field->idx = count($this->fields);
    $this->fields[] = $field;
    $this->name2field[$name] = $field;
    $field->setParent($this);
    return true;
  }

  public function insertField($field, $idx = 0) {
    if (!($field instanceof vsRegsField)) $this->addError('errorNotField');
    $idx = (int)$idx;
    if ($idx < 0 || $idx > $this->getFieldsCount()) $this->addError('errorWrongIndex', array('idx' => $idx));
    array_splice($this->fields, $idx, 0, array($field));
    $i = 0;
    foreach ($this->fields as &$field) $field->idx = $i++;
    $this->name2field[$field->getName()] = $field;
    $field->setParent($this);
    return true;
  }

  public function delFieldByName($name) {
    $idx = $field->getFieldIdxByName($name);
    if ($idx < 0) $this->addError('errorWrongIndex', array('name' => htmlspecialchars($name)));
    array_splice($this->fields, $idx, 1);
    $cnt = count($this->fields);
    for ($i = $idx; $i < $cnt; $i++) $field[$i]->idx--;
    unset($this->name2field[$name]);
    return true;
  }

  public function delFieldByIndex($idx) {
    $idx = (int)$idx;
    if ($idx < 0 || $idx >= $this->getFieldsCount()) $this->addError('errorWrongIndex', array('idx' => $idx));
    $cnt = count($this->fields);
    for ($i = $idx; $i < $cnt; $i++) $field[$i]->idx--;
    $name = $this->getFieldByIndex($idx)->name;
    array_splice($this->fields, $idx, 1);
    unset($this->name2field[$name]);
    return true;
  }

  public function addPlugin($plugin) {
    if ($plugin->unique()) {
      $cls = get_class($plugin);
      foreach ($this->plugins as $p)
        if (get_class($p) == $cls) return $p;
    }
    $this->plugins[] = $plugin;
    $plugin->setParent($this);
    return $plugin;
  }

  public function addBulkAction($action, $desc, $neededRole = vsRegs::ROLE_ADMIN) {
    if (isset($this->additionalBulkActions[$action])) return false;
    $this->additionalBulkActions[$action] = array($desc, $neededRole);
    return true;
  }

  public function setValues($data, $breakOnError = false) {
    $allOk = true;
    foreach ($this->fields as $field) {
      $name = $field->getName();
      if (isset($data[$name])) {
        if (!$field->setValue($data[$name]))
          if ($breakOnError)
            $this->addError('errorFailedSet', array('name' => htmlspecialchars($name)));
          else
            $allOk = false; 
      }
    }
    return $allOk;
  }

  public function clearValues() {
    $this->currentId = null;
    foreach ($this->fields as $field) {
      $field->clearValue();
      $this->runPlugins("clearFieldValue", $field);
    }
    $this->runPlugins("clearValues");
  }

  public function tableName($name) {
    return (empty($this->params["code"]) ? "" : $this->params["code"]."_").$name;
  }

  // Adapt the field name (i.e., prepened something)
  // Always wrap it in htmlspecialchars() as it is not done when this function is called
  public function fieldName($name) {
    return htmlspecialchars((empty($this->params["code"]) ? $this->params["code"]."_" : "").$name);
  }

  private function appendCode(&$res, &$used, $code) {
    if (is_array($code))
      foreach ($code as $key => $val) {
        if (strspn($key, "0123456789") < strlen($key))
          if (isset($used[$key]) && $used[$key])
            continue;
          else
            $used[$key] = true;
        $res .= (empty($res) ? "" : "\n\n").trim($val);
      }
    else
      $res .= (empty($res) ? "" : "\n\n").trim($code);
  }

  public function cssCode() {
    $res = "";
    $selectors = array();
    foreach ($this->fields as $field)
      $this->appendCode($res, $selectors, $field->cssCode());
    foreach ($this->plugins as $plugin)
      $this->appendCode($res, $selectors, $plugin->cssCode());
    return $res;
  }

  public function jsCode() {
    $res = "";
    $functions = array();
    foreach ($this->fields as $field)
      $this->appendCode($res, $functions, $field->jsCode());
    foreach ($this->plugins as $plugin)
      $this->appendCode($res, $functions, $plugin->jsCode());
    return $res;
  }

  protected function mergeHtmlParams(&$arr1, $arr2) {
    if (is_array($arr2))
      foreach ($arr2 as $k => $v) {
        $k = strtolower($k);
        if (isset($arr1[$k]))
          $arr1[$k] .= " ".$v;
        else
          $arr1[$k] = $v;
      }
  }

  public function htmlParams2str($params, $prefix = "") {
    if (!is_array($params)) return "";
    $res = "";
    foreach($params as $k => $v)
      $res .= " $k=\"".htmlspecialchars($v)."\"";
    return (empty($res) ? "" : $prefix.$res);
  }

  // Generates and returns HTML code for the registration code
  // Returns empty string if the deadline is defined and has passed
  // Arguments:
  //   scope -- true if the data is to be edited; false if it is to be inserted
  //   extras -- associative array with "head" and "foot", both strings to be added before or after form fields
  public function generateDataBox($scope = vsRegs::SCOPE_INPUT, $extras = null) {
    if (!$this->hasRole(vsRegs::ROLE_ADMIN) && $this->deadlinePassed("Registration")) return "";
    if ($this->autoHandled) return "";
    if (isset($this->params["registrationDeadline"]) && $this->params["registrationDeadline"] < time())
      return "";
    $res = $this->runPlugins("beforeRegisterBox", $scope);
    // Start box
    if (!empty($this->params["registrationCSS"])) $res .= "<div class=\"".$this->params["registrationCSS"]."\">\n\n";
    // Box title
    switch ($scope) {
      case vsRegs::SCOPE_INPUT: $fn = "registrationTitle"; break;
      case vsRegs::SCOPE_EDIT: $fn = "editTitle"; break;
      case vsRegs::SCOPE_OUTPUT: $fn = "infoTitle"; break;
      default: return "";
    }
    if (!empty($this->params[$fn])) $res .= "<div class=\"title\">".$this->params[$fn]."</div>\n\n";
    // Legend (i.e., explanation of the mandatory fields)
    switch ($scope) {
      case vsRegs::SCOPE_INPUT:
        if (!empty($this->params["registrationLegend"]))
          $res .= "<div class=\"alert alert-info\">".$this->params["registrationLegend"]."</div>\n\n";
        break;
      case vsRegs::SCOPE_EDIT:
        if (!empty($this->params["editLegend"]))
          $res .= "<div class=\"alert alert-info\">".$this->params["editLegend"]."</div>\n\n";
        break;
      case vsRegs::SCOPE_OUTPUT:
        if (!empty($this->params["infoLegend"]))
          $res .= "<div class=\"alert alert-info\">".$this->params["infoLegend"]."</div>\n\n";
        break;
      default: return "";
    }
    // Form start
    if ($scope != vsRegs::SCOPE_OUTPUT) {
      $res .= "<form";
      $args = array(
        "method" => "post",
      );
      if (!empty($this->params["formAction"])) $args["action"] = $this->params["formAction"];
      foreach ($this->fields as $field) {
        $a = $field->extraFormArgs();
        if (is_array($a)) $args = array_merge($args, $a);
      }
      foreach ($args as $key => $value)
        $res .= " $key=\"".htmlspecialchars($value)."\"";
      $res .= ">\n\n";
      if ($scope == vsRegs::SCOPE_EDIT && !empty($this->currentId))
        $res .= "<input type=\"hidden\" name=\"".$this->params["fieldId"]."\" value=\"".((int)$this->currentId)."\" />\n\n";
    }
    // Head extras
    $res .= $this->runPlugins("registerBoxHead", $scope);
    if ($scope == vsRegs::SCOPE_INPUT && !empty($this->params["registrationHead"]))
      $res .= $this->params["registrationHead"]."\n\n";
    if ($scope == vsRegs::SCOPE_EDIT && !empty($this->params["editHead"]))
      $res .= $this->params["editHead"]."\n\n";
    if ($scope == vsRegs::SCOPE_OUTPUT && !empty($this->params["outputHead"]))
      $res .= $this->params["outputHead"]."\n\n";
    if (is_array($extras) && !empty($extras["head"]))
      $res .= $extras["head"]."\n\n";
    // Fields
    foreach (array(true, false) as $beforeTable) {
      if (!$beforeTable) {
        // Table head
        $res .= "<table".(empty($this->params["registrationCSS"]) ? "" : " class=\"".$this->params["registrationCSS"]."\"").">\n\n";
        // Table head extras
        if (is_array($extras) && !empty($extras["thead"]))
          $res .= $extras["thead"]."\n\n";
      }
      foreach ($this->fields as $field) {
        if ($beforeTable === $field->visibleInRegisterBox) continue;
        $res .= $this->runPlugins("beforeRegisterBoxField", array($scope, $field));
        if (!$field->isVisible($scope)) continue;
        if ($field->visibleInRegisterBox) {
          $res .= "  <tr valign=\"top\">\n    <th".$this->htmlParams2str($field->getInfoboxTitleParams($scope)).">";
          $res .= $this->runPlugins("beforeRegisterBoxFieldTitle", array($scope, $field));
          $ftitle = $field->getTitle();
          if (!empty($ftitle)) {
            if ($field->mandatory && !empty($this->params["mandatoryMark"]) && $scope != vsRegs::SCOPE_OUTPUT) $res .= $this->params["mandatoryMark"];
            $res .= $ftitle; // Took away .":" ie a colon between the legend and box
            if ($scope != vsRegs::SCOPE_OUTPUT) $res .= $field->getSubtitle();
          }
          $res .= $this->runPlugins("afterRegisterBoxFieldTitle", array($scope, $field));
          $res .= "</th>\n    <td".$this->htmlParams2str($field->getInfoboxInputParams($scope)).">";
        }
        $res .= $this->runPlugins("beforeRegisterBoxFieldData", array($scope, $field));
        switch ($scope) {
          case vsRegs::SCOPE_INPUT: $res .= $field->getHtmlInput(); break;
          case vsRegs::SCOPE_EDIT: $res .= $field->getHtmlEdit(); break;
          case vsRegs::SCOPE_OUTPUT: $res .= $field->getHtmlOutput(); break;
        }
        $res .= $this->runPlugins("afterRegisterBoxFieldData", array($scope, $field));
        if ($field->visibleInRegisterBox) {
          $res .= "</td>\n  </tr>\n\n";
          $res .= $this->runPlugins("afterRegisterBoxField", array($scope, $field));
        }
        //$res .= "<!-- ".$field->getName().",$scope -->\n";
      }
      if (!$beforeTable) {
        // Table foot extras
        if (is_array($extras) && !empty($extras["tfoot"]))
          $res .= $extras["tfoot"]."\n\n";
        if ($scope != vsRegs::SCOPE_OUTPUT) {
          // Submit and reset buttons
          $res .= "  <tr>\n    <td colspan=\"2\" > <input class=\"btn btn-danger\"  style=\"float:left\" type=\"reset\" value=\"".$this->text('resetFields')."\" /><input class=\"btn btn-success\" style=\"float:right\" type=\"submit\" name=\"".$this->fieldName("submit")."\" value=\"".$this->text('submit')."\" /></td>\n  </tr>\n\n";
          
        }
        // End input table
        $res .= "</table>\n\n";
      }
    }
    // Foot extras
    $res .= $this->runPlugins("registerBoxFoot", $scope);
    if (is_array($extras) && !empty($extras["foot"]))
      $res .= $extras["foot"]."\n\n";
    $res .= $this->runPlugins("registerBoxFoot", $scope);
    if ($scope == vsRegs::SCOPE_INPUT && !empty($this->params["registrationFoot"]))
      $res .= $this->params["registrationFoot"]."\n\n";
    if ($scope == vsRegs::SCOPE_EDIT && !empty($this->params["editFoot"]))
      $res .= $this->params["editFoot"]."\n\n";
    if ($scope == vsRegs::SCOPE_OUTPUT && !empty($this->params["outputFoot"]))
      $res .= $this->params["outputFoot"]."\n\n";
    // Form end
    if ($scope != vsRegs::SCOPE_OUTPUT) $res .= "</form>\n\n";
    // End box
    if (!empty($this->params["registrationCSS"])) $res .= "</div>\n\n";
    $res .= $this->runPlugins("afterRegisterBox", $scope);
    // Return generated string
    return $res;
  }

  // Get an array of all required tables
  public function getTables($includeMain = true) {
    $tables = ($includeMain ? array($this->tableName("attend") => 1) : array());
    foreach ($this->fields as $field) {
      $ftables = $field->requiredTables();
      if (isset($ftables))
        foreach((array)$ftables as $table)
          $tables[$table] = 1;
    }
    return array_keys($tables);
  }

  public function createTables() {
    $dropIfExists = (isset($params["dropIfExists"]) ? $params["dropIfExists"] : true);
    $extraDefs = (isset($params["extraDefs"]) ? $params["extraDefs"] : "");
    if ($dropIfExists) {
      $sth = $this->query("drop table if exists ".implode(", ", $this->getTables()));
      if (!$sth || $sth->errorCode() != '00000') {
        $this->lastPDOerrorInfo = $sth->errorInfo();
        $this->addError('errorDrop', array('tables' => $this->getTables()));
      }
    }
    $sql =
      "create table `".$this->tableName("attend")."` (\n".
      "  `".$this->params["fieldId"]."` integer auto_increment primary key";
    foreach ($this->fields as $field) {
      $fsql = $field->sqlDefinition();
      if (is_array($fsql)) {
        foreach ($fsql as $def)
          $sql .= ",\n  $fsql";
      } elseif (empty($fsql))
        continue;
      else
        $sql .= ",\n  $fsql";
    }
    if (!empty($extraDefs)) $sql .= ",\n".$extraDefs;
    foreach ($this->fields as $field) {
      $extra = $field->sqlExtraDefinition();
      if (!empty($extra))
        foreach ((array)$extra as $def)
          $sql .= ",\n  ".$def;
    }
    $sql .= "\n) default charset=utf8 collate=utf8_bin";
    $sth = $this->query($sql);
    if (!$sth || $sth->errorCode() != '00000') {
      $this->lastPDOerrorInfo = $sth->errorInfo();
      $this->addError('errorCreatingAttendanceTable', array($sql => htmlspecialchars($sql)));
    }
    foreach ($this->fields as $field) {
      $fsql = $field->sqlCreateTables();
      if (empty($fsql)) continue;
      foreach ((array)$fsql as $sql) {
        $sth = $this->query($sql);
        if (!$sth || $sth->errorCode() != '00000') {
          $this->lastPDOerrorInfo = $sth->errorInfo();
          $this->addError('errorCreatingExtraTables', array('name' => $field->getName(), 'sql' => htmlspecialchars($sql)));
        }
      }
    }
    return true;
  }

  public function saveData() {

    // Prepare all data
    $data = array("attend" => array());
    $fieldId = $this->params["fieldId"];
    $doInsert = (empty($this->currentId) || !$this->canDo("Edit data", vsRegs::ROLE_EDIT));
    foreach ($this->fields as $field) {
      ($doInsert ? $field->beforeInsert() : $field->beforeEdit());
      $tmp = $field->exportValueToDBrow();
      if (is_array($tmp))
        foreach ($tmp as $tname => $values) {
          if (!isset($data[$tname])) $data[$tname] = array();
          foreach ($values as $key => $val)
            $data[$tname][$key] = $val;
      }
    }

    // Save all data
    foreach ($data as $tname => $values) {

      // Prepare SQL statement
      $sql = "";
      foreach ($values as $key => $val)
        $sql .= (empty($sql) ? "" : ", ")."$key = :$key";

      // Run plugins and finish SQL statement
      if ($doInsert) {
        $sql = "insert into ".$this->tableName("attend")." set $sql";
        if ($tname === "attend")
          $this->runPlugins("beforeAttendInsert");
        else
          $this->runPlugins("beforeExtraInsert", $tname);
      } else {
        $sql = "update ".$this->tableName("attend")." set $sql where id=".((int)$this->currentId);
        if ($tname === "attend")
          $this->runPlugins("beforeAttendUpdate");
        else
          $this->runPlugins("beforeExtraUptade", $tname);
      }

      // Save data to the database
      $sth = $this->queryAndCreate($sql, $values);
      if (!$sth) {
        if ($this->checkErrorInfo('23000', '1062'))
          return ($this->params["debug"] ?
            $this->addError(htmlspecialchars($this->lastPDOerrorInfo[2]).".") :
            $this->addError('errorNotUnique')
          );
        if ($this->params["debug"]) {
          foreach ($values as $key => &$val)
            if (is_scalar($val)) $val = htmlspecialchars($val); else $val = "<span style=\"color: red;\">".$this->text('notScalar')."!</span>";
          return $this->addError('errorSavingAttendanceData', array('sql' => $sql, 'values' => $values));
        } else
          return $this->addError('errorSavingAttendanceData');
      }

      // Run plugins
      if ($doInsert) {
        if ($tname === "attend") {
          $this->currentId = $this->dbh->lastInsertId($this->params["fieldId"]);
          $this->runPlugins("afterAttendInsert");
        } else
          $this->runPlugins("afterExtraInsert", $tname);
        $this->addInfo('successInsert');
      } else {
        if ($tname === "attend")
          $this->runPlugins("afterAttendUpdate");
        else
          $this->runPlugins("afterExtraUpdate", $tname);
        $this->addInfo('successUpdate');
      }
    }

    $ok = true;
    $this->currentData = array($fieldId => $this->currentId);

    // Extra saving, with only ID available (no current data!)
    $this->currentDataLoaded = true; // No fields/plugins may require the data here, as still not all of it saved
    if ($doInsert) {
      foreach ($this->fields as $field)
        if (!$field->insertData()) $ok = $this->addError('errorFailedInsertData', array('name' => $field->getName()));
    } else {
      foreach ($this->fields as $field)
        if (!$field->editData()) $ok = $this->addError('errorFailedEditData', array('name' => $field->getName()));
    }

    // Post-saving operations
    $this->currentDataLoaded = false; // If any field/plugin requires the data, it will have to reload it
    if ($doInsert) {
      foreach ($this->fields as $field)
        if (!$field->afterInsert()) $ok = $this->addError('errorFailedAfterInsert', array('name' => $field->getName()));
    } else {
      foreach ($this->fields as $field)
        if (!$field->afterEdit()) $ok = $this->addError('errorFailedAfterEdit', array('name' => $field->getName()));
    }
    if (!$ok) $this->clearInfos();
    return $ok;
  }

  // Delete data for the member $id (null for all)
  public function deleteData($id = null) {
    $fieldPid = $this->params["fieldPid"];
    $fieldId = $this->params["fieldId"];
    $atname = $this->tableName("attend");
    $ok = true;

    // Get IDs if none were provided
    if (!isset($id)) {
      $sth = $this->query("select $fieldId from $atname");
      if (!$sth || $this->lastPDOerrorInfo[0] != '00000') return $this->addError('errorGettingIDs');
      $id = $sth->fetchAll(PDO::FETCH_COLUMN, 0);
    }
    if (!$id) return true;
    $id = array_map("intval", (array)$id);
    $ids = implode(',', $id);

    // Get the array of tables from which the data must be read
    $tables = array();
    foreach ($this->fields as $field) {
      $ftables = $field->dataRequiredForDelete();
      if (isset($ftables))
        foreach((array)$ftables as $table)
          $tables[$table] = 1;
    }
    $tables = array_keys($tables);

    // Read the data
    $data = array();
    $atname = $this->tableName("attend");
    foreach ($tables as $tname) {
      $idField = ($atname == $tname ? $fieldId : $fieldPid);
      $sth = $this->query("select * from $tname where $idField in ($ids)");
      if (!$sth || $this->lastPDOerrorInfo[0] != '00000') return $this->addError('errorGettingMembersData');
      while ($tdata = $sth->fetch(PDO::FETCH_ASSOC))
        $data[$tdata[$idField]][$tname][] = $tdata;
    }

    // Invoke fields' cleanups
    $debug = $this->params["debug"];
    foreach ($data as $mid => $mdata)
      foreach ($this->fields as $field)
        if (!$field->deleteData($mid, $mdata) && $debug)
          $ok = $this->addError('errorDeletingExtraData', array('user' => $mid, 'name' => $field->getName()));

    // Delete the data in all tables
    foreach ($this->getTables() as $tname) {
      $idField = ($atname == $tname ? $fieldId : $fieldPid);
      $sth = $this->query("delete from $tname where $idField in ($ids)");
      if ($debug && (!$sth || $this->lastPDOerrorInfo[0] != '00000'))
        $ok = $this->addError('errorDeletingMembersData', array('tname' => $tname));
    }

    return $ok;
  }

  // Form functions pick data from the $_POST
  public function readValuesFromPost($scope = vsRegs::SCOPE_INPUT) {
    $this->clearValues();
    $invalid = array(); // For debugging purposes only
    if ($scope == vsRegs::SCOPE_EDIT && !empty($_POST["id"])) {
      $this->currentId = (int)$_POST["id"];
      $this->getCurrentData(); // Read the data
    }
    //print_r($this->getFieldByName("confirm")->getValue()); exit;
    foreach ($this->fields as $field)
      if ($this->runPlugins("preprocessPostedData", array($scope, $field)))
        if (!$field->readValueFromPost($scope) || !$this->runPlugins("postprocessPostedData", array($scope, $field)))
            $invalid[] = "\"".htmlspecialchars($field->getTitle())."\"";
    if ($invalid)
      if ($this->params["debug"])
        if (count($invalid) == 1)
          return $this->addError('errorFieldInvalidDataDebug', array('name' => $invalid[0]));
        else
          return $this->addError('errorFieldsInvalidDataDebug', array('names' => $invalid));
      else
        return false;
    return true;
  }

  // Return array of rows
  // $full -- all data, including that from the extra tables
  // $id -- an id or an array of ids (null for all)
  // $extra -- extra select arguments, i.e., "order by lastname" or "limit 17,19"
  // Due to the specific organization of data, $full == true && $id == null may be quite slow for larger tables
  public function membersInfo($full = false, $id = null, $extra = "") {
    $fieldPid = $this->params["fieldPid"];
    $fieldId = $this->params["fieldId"];
    $atname = $this->tableName("attend");
    $sql = "select * from $atname";
    if (isset($id) && (is_array($id) && $id || !empty($id)))
      $sql .= $idCrit = " where $fieldId in (".implode(",", array_map("intval", (array)$id)).")";
    else
      $idCrit = "";
    if (!empty($extra)) $sql .= " $extra";
    $sth = $this->query($sql);
    if (!$sth) return $this->addError('errorFetchAttendant');
    $data = $sth->fetchAll(PDO::FETCH_ASSOC);
    if ($full) {
      if (isset($id) && (is_array($id) && $id || !empty($id)))
        $sql .= $idCrit = " where $fieldPid in (".implode(",", array_map("intval", (array)$id)).")";
      else
        $idCrit = "";
      $tables = $this->getTables(false);
      foreach ($tables as $tname) {
        $sth = $this->query($sql = "select * from $tname$idCrit");
        if (!$sth) return $this->addError('errorFetchData', array('tname' => $tname));
        while ($row = $sth->fetch(PDO::FETCH_ASSOC))
          if (isset($row[$fieldPid]))
            foreach ($data as &$urow)
              if (isset($urow[$fieldId]) && $urow[$fieldId] === $row[$fieldPid]) {
                $urow[$tname][] = $row;
                break;
              }
      }
    }
    return $data;
  }

  public function importValuesFromDBrow($data) {
    foreach ($this->fields as $field) {
      $field->importValueFromDBrow($data);
      $this->runPlugins("processImportedData", $field);
    }
  }

  protected function autoNeedsExtraTables() {
    foreach ($this->fields as $field)
      if ($field->visibleInMembersTable && $field->isVisible(vsRegs::SCOPE_TABLE))  {
        $ftables = $field->requiredTables();
        if (is_array($ftables) && $ftables) return true;
      }
    return false;
  }

  // Use $grabFull = true if the data from the extra tables is needed
  public function membersTable() {
    $fieldId = $this->params["fieldId"];
    $grabFull = $this->autoNeedsExtraTables();
    $extra = (empty($this->params["membersTableSelectExtra"]) ? "" : $this->params["membersTableSelectExtra"]);
    $memberList = $this->membersInfo($grabFull, null, $extra);
    $code = $this->params["code"];
    $res = $this->runPlugins("beforeMembersTable", $memberList);
    $canDoBulk = false;
    foreach($this->additionalBulkActions as $action => $dr) // $dr = array($desc, $role)
      if ($this->hasRole($dr[1])) {
        $canDoBulk = true;
        break;
      }
    if ($canDoBulk) $res .= "<form method=\"post\">\n\n";
    $res .=
      "<table".
      (!isset($this->params["membersCSS"]) || empty($this->params["membersCSS"]) ? "" : " class=\"".$this->params["membersCSS"]."\"").
      (!isset($this->params["membersId"]) || empty($this->params["membersId"]) ? "" : " id=\"".$this->params["membersId"]."\"").
      ">\n\n<thead>\n\n  <tr>\n";
    foreach ($this->fields as $field)
      if ($field->visibleInMembersTable && $field->isVisible(vsRegs::SCOPE_TABLE)) {
        $res .= "    <th".$this->htmlParams2str($field->getColumnTitleParams()).">".$field->getColumnTitle()."</th>\n";
      }
    if ($canDoBulk) $res .= "    <th class=\"".$this->params["bulkCSS"]."\">".$this->text('admin')."</th>";
    $res .= "  </tr>\n\n</thead>\n\n<tbody>\n\n";
    foreach ($memberList as $data) {
      $this->clearValues();
      $this->currentData = $data;
      $this->currentId = (empty($data[$fieldId]) ? null : $data[$fieldId]);
      $this->importValuesFromDBrow($data);
      $trParams = array();
      if ($this->hasRole(vsRegs::ROLE_VIEW))
        $trParams["onclick"] = "window.location='?id=".$data[$this->params["fieldId"]]."'; return false;";
      foreach ($this->fields as $field)
        $this->mergeHtmlParams($trParams, $field->getRowParams());
      $res .= $this->runPlugins("beforeMembersTableRow", $data);
      $res .= "  <tr".$this->htmlParams2str($trParams).">\n";
      foreach ($this->fields as $field)
        if ($field->visibleInMembersTable && $field->isVisible(vsRegs::SCOPE_TABLE)) {
          $res .= $this->runPlugins("beforeMembersTableCell", $field);
          $res .= "    <td".$this->htmlParams2str($field->getCellParams()).">".$field->getHtmlCell()."</td>\n";
          $res .= $this->runPlugins("afterMembersTableCell", $field);
        }
      if ($canDoBulk) $res .= "    <td class=\"".$this->params["bulkCSS"]."\" onClick=\"if (event.stopPropagation) event.stopPropagation(); if (window.event) window.event.cancelBubble = true;\" title=\"".$this->text('bulkCheckHint')."\"><input type=\"checkbox\" name=\"${code}Chk[]\" value=\"".$this->currentId."\" /></td>\n";
      $res .= "  </tr>\n\n";
      $res .= $this->runPlugins("afterMembersTableRow", $data);
    }
    $res .= "</tbody>\n\n</table>\n\n";
    if ($canDoBulk) {
      $res .= "    <div class=\"".$this->params["bulkCSS"]."\">".$this->text('bulkActionsLabel').": <select name=\"${code}BulkAction\" id=\"${code}BulkAction\"><option value=\"\">".$this->text('bulkNone')."</option>";
      if (isset($this->additionalBulkActions) && is_array($this->additionalBulkActions))
        foreach($this->additionalBulkActions as $action => $dr) // $dr = array($desc, $role)
          if ($this->hasRole($dr[1]))
            $res .= "<option value=\"$action\">".htmlspecialchars($dr[0])."</option>";
      $res .= "</select> <input type=\"submit\" value=\"".$this->text('bulkExecute')."\" onClick=\"var act=document.getElementById('${code}BulkAction'); if (!act) return false; if (act.value) return true; alert('".htmlspecialchars($this->text('bulkNoAction'), ENT_QUOTES)."'); return false;\" /></div>\n\n";
    }
    $res .= $this->runPlugins("afterMembersTable", $memberList);
    if ($canDoBulk) $res .= "</form>\n\n";
    return $res;
  }

  private function autogenerateDataBox($scope, $id, $extras = null) {
    $data = $this->loadMemberData((int)$id);
    if (!$data) return "";
    $res = $this->generateDataBox($scope, $extras);
    $this->autoHandled = true;
    return $res;
  }

  public function handleRequests() {
    $code = $this->params["code"];
    $this->clearValues();
    $this->clearMessages();
    if (!empty($_GET["id"]))
      $this->currentId = (int)$_GET["id"];
    elseif (!empty($_GET["edit"]))
      $this->currentId = (int)$_GET["edit"];

    $res = $this->runPlugins("beforeHandleRequests");
    if (!empty($res)) {
      $this->autoHandled = true;
      return $res;
    }
    if ($this->autoHandled) return "";

    if (isset($_POST["${code}BulkAction"]) && isset($_POST["${code}Chk"])) {
      $action = $_POST["${code}BulkAction"];
      $ids = array_map("intval", (array)$_POST["${code}Chk"]);
      $this->autoHandled = true;
      switch ($action) {
        case "delete":
          if ($this->deleteData($ids))
            $this->addInfo('successDelete');
          return "";
        default:
          return $this->runPlugins("bulkAction", array($action, $ids));
      }
    }
    if (isset($_POST["submit"])) {
      $scope = (!empty($_POST["id"]) && $this->hasRole(vsRegs::ROLE_EDIT) ? vsRegs::SCOPE_EDIT : vsRegs::SCOPE_INPUT);
      if ($scope === vsRegs::SCOPE_INPUT && $this->deadlinePassed("Registrations")) return "";
      $this->autoHandled = true;
      if (!$this->readValuesFromPost($scope) || !$this->saveData()) {
        if ($scope === vsRegs::SCOPE_INPUT) $this->addError('goBack');
        return "";
      }
      return "";
    }

    if (isset($_GET["list"]) && $this->hasRole(vsRegs::ROLE_LIST)) {
      $this->autoHandled = true;
      return $this->membersTable();
    }

    if (!empty($_GET["id"])) {
      if ($this->hasRole(vsRegs::ROLE_VIEW)) {
        $extras = array();
        if ($this->hasRole(vsRegs::ROLE_EDIT))
          $extras["foot"] = "<div class=\"foot\"><a href=\"?edit=".((int)$_GET["id"])."\">".$this->params["editTitle"]."</a></div>\n\n";
        return $this->autogenerateDataBox(vsRegs::SCOPE_OUTPUT, $_GET["id"], $extras);
      }
      if ($this->hasRole(vsRegs::ROLE_EDIT))
        return $this->autogenerateDataBox(vsRegs::SCOPE_EDIT, $_GET["id"]);
    }

    if (!empty($_GET["edit"]) && $this->hasRole(vsRegs::ROLE_EDIT))
      return $this->autogenerateDataBox(vsRegs::SCOPE_EDIT, $_GET["edit"]);

    $res = $this->runPlugins("afterHandleRequests");
    if (!empty($res)) {
      $this->autoHandled = true;
      return $res;
    }

    return "";
  }

}

/***********************************************************
 *** An example class to show how this stuff can be used ***
 ***********************************************************/

class vsRegsExample extends vsRegs {

  function __construct($params, $role = vsRegs::ROLE_USER) {
    if (!isset($params["fields"])) {
      $fieldTitle = new vsRegsFieldSelect("title", "Title", true);
      $fieldTitle->assign(array('', 'Dr', 'Professor', 'Mr', 'Miss', 'Mrs', 'Ms'), "");
      $params["fields"] = array(
        $fieldTitle,
        new vsRegsFieldInput("firstname", "First name", true),
        new vsRegsFieldInput("lastname", "Last name", true),
        new vsRegsFieldInputUnique("email", "E-mail", true),
        new vsRegsFieldInput("institution", "Institution", true),
        new vsRegsFieldText("remarks", "Remarks"),
        new vsRegsFieldAvatar("avatar", "Avatar"),
        new vsRegsFieldCaptcha("abc", "Bot-unfriendly test"), // "abc" = "anti-bot check/captcha"
      );
    }
    parent::__construct($params, $role);
    if (empty($this->params["membersTableSelectExtra"]))
      $this->params["membersTableSelectExtra"] = "order by lastname, firstname, ".$this->params["fieldId"];
    $this->getFieldByName("remarks")->visibleInMembersTable = false;
  }

}

?>
